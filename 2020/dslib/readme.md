# dslib

Фреймворк для написания и тестирования домашних заданий по курсу "Распределенные системы".

## Установка

Для работы с dslib вам понадобятся:

- Python 3.5+
- Пакет [grpcio](https://pypi.org/project/grpcio/)
- Пакет [protobuf](https://pypi.org/project/protobuf/)

## Написание приложений

dslib поддерживает написание приложений, состоящих из набора процессов, которые взаимодействуют путем обмена сообщениями и могут выполняться распределенно. Процессы также могут принимать и отправлять локальные сообщения, которые предназначены для взаимодействия с внешними клиентами.

Поддерживаются две модели программирования, описываемые далее.

### Коммуникатор (send/recv)

Данная модель программирования основана на использовании _коммуникатора_ - примитива, реализующего следующие функции для отправки и приема сообщений:

- `send(message, recepient)` - (асинхронно) отправляет сообщение `messsage` процессу с адресом `recepient`;
- `recv(timeout)` - ожидает и возвращает входящее сообщение или `None`, если сообщение не пришло в течение `timeout` секунд;
- `send_local(message)` - отправляет локальное сообщение;
- `recv_local()` - ождает и возвращает локальное сообщение.

У каждого процесса должен быть свой экземпляр класса [Communicator](comm.py). При создании коммуникатора указывается имя процесса и опционально адрес процесса в формате `host:port`. Если адрес не указан, то коммуникатор использует любой свободный порт.

В рамках данной модели вы имеете полный контроль над выполнением процесса и сами принимаете решение о том, когда блокировать его выполнение, вызывая `recv()`. Аналогом данной модели на практике является [Message Passing Interface (MPI)](https://en.wikipedia.org/wiki/Message_Passing_Interface).

Пример приложения на основе этой модели можно найти [здесь](examples/ping-pong/comm).

### Обработка событий (callbacks)

Данная модель программирования основана на использовании среды выполнения процессов (runtime), которая вызывает реализацию процесса для обработки событий - входящих сообщений и таймеров. В ходе обработки события процесс может отправлять новые сообщения или создавать таймеры, срабатывающие через заданное время.

Процесс должен реализовывать стандартный интерфейс [Process](process.py), включающий следующие функции:

- `name()` - возвращает имя процесса;
- `receive(ctx, message)` - вызывается runtime при получении сообщения, в параметре `ctx` передается контекст (см. ниже);
- `on_timer(ctx, timer)` - вызывается при срабатывании таймера, передается имя таймера и контекст.

Гарантируется, что runtime не будет одновременно делать несколько вызовов процесса, то есть обработка сообщений и таймеров в рамках процесса ведется строго последовательно.

Взаимодействие процесса с runtime устроено через интерфейс [Context](process.py), включающий следующие функции:

- `addr()` - возвращает адрес процесса;
- `send(message, recepient)` - отправляет сообщение `messsage` процессу с адресом `recepient`;
- `send_local(message)` - отправляет локальное сообщение;
- `set_timer(timer, interval)` - создает таймер с именем `timer`, который сработает через `interval` секунд;
- `cancel_timer(timer)` - отменяет таймер с именем `timer`.

При создании runtime надо передать экземпляр вашего процесса. Для простоты runtime поддерживает выполнение только одного процесса. После создания runtime следует запустить её работу, вызвав `start()`. Дальнейшее выполнение программы происходит внутри runtime до остановки программы.

В рамках данной модели выполнение процесса контролируется runtime, а вам требуется написать только логику обработки событий (сообщений, таймеров). Аналогом данной модели на практике являются среды выполнения [акторов](https://en.wikipedia.org/wiki/Actor_model), например в языке Erlang.

Пример приложения на основе этой модели можно найти [здесь](examples/ping-pong/proc).

## Запуск и взаимодействие с приложениями

Процессы вашего приложения можно запускать в отдельных консолях как на одной, так и на разных машинах. Для удобства взаимодействия с процессами поддерживается прием и вывод локальных сообщений через консоль. Пример того, как выглядит запуск и взаимодействие с процессами можно найти [здесь](examples/ping-pong).

## Тестирование приложений

dslib поддерживает тестирование приложений на основе перехвата и манипуляции сообщениями, пересылаемыми между процессами. Во время тестирования процессы подключаются к тестирующему серверу, который управляет доставкой сообщений и порядком происходящих в системе событий в соответствии с заданными в тесте настройками. Например, сервер может отбрасывать сообщения, задерживать их передачу, переупорядочивать события (приход сообщений, срабатывание таймеров). [Здесь](examples/ping-pong/test.py) можно найти примеры тестов, иллюстрирующие данные возможности dslib.