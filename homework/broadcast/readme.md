# Рассылка в группе

В данной задаче Вам надо будет реализовать механизм рассылки сообщений в группе c описанными далее гарантиями.

Имеется распределенное приложение типа чата, пользователи которого общаются путем обмена сообщениями. Для простоты будем считать что число пользователей фиксировано, чат один и сообщения в нём доставляются всем пользователям приложения (broadcast). С каждым пользователем связан процесс Peer, который занимается приемом сообщений от своего пользователя, доставкой их остальным процессам в группе, а также отображением полученных от других процессов сообщений своему пользователю. Как обычно, взаимодействие с пользователем (прием и отображение сообщений) реализованы с помощью локальных сообщений. Также будем считать, что каждое отправляемое в систему сообщение уникально в пределах рассматриваемого выполнения системы (например, в течение теста).

Процессы взаимодействуют через надежный транспорт, гарантирующий доставку сообщений, отсутствие повторов или появлений сообщений "из воздуха". Однако могут отказывать сами процессы путем внезапной остановки, иногда в самый неподходящий момент, например посредине рассылки сообщения. При этом, даже если процесс успел отправить сообщение до того как "упал", доставка этого сообщения уже не гарантируется. Ведь, как мы знаем из прошлых заданий, реализация надежного транспорта требует непосредственного участия отправителя. Будем считать, что отказавший процесс останавливается навсегда, то есть не возвращается в систему. Если в ходе выполнения процесс не отказал, будем называть его _корректным_. Также будем считать, что в ходе выполнения большинство процессов корректные. Например, если процессов 5, то отказать могут не более 2.

Ваша реализация рассылки сообщений должна удовлетворять следующим свойствам:

1. Сообщения отображаются пользователю не более одного раза (нет повторов).
2. Если пользователю отображено сообщение _m_ от отправителя _s_, то _m_ было ранее отправлено пользователем процесса _s_.
3. Если корректный процесс _p_ разослал сообщение _m_, то _p_ должен в конце концов доставить (отобразить пользователю) _m_.
4. Если сообщение _m_ было отображено некоторому пользователю (даже если его процесс потом отказал), то _m_ будет в конце концов отображено каждым корректным процессом.
5. Если некоторый процесс разослал сообщение _m1_ до сообщения _m2_, то любой корректный процесс, который доставил _m2_, доставит _m1_ до _m2_.

Часть из этих свойств уже обеспечивается в силу описанных выше предположений, остальные Вам надо реализовать самому.

Ваша реализация не должна делать каких-либо предположений о том, жив ли удаленный процесс или нет, о временах доставки и обработки сообщений. Позже в курсе мы научимся реализовывать детектор отказов, сейчас это делать не требуется.

Также описанные выше требования не гарантируют, что все пользователи будут видеть сообщения в одном порядке или всегда видеть ответы на сообщение после самого сообщения. Вы можете реализовать данные гарантии по желанию и получить за это бонусные баллы.

## Тестирование

Необходимые зависимости должны быть уже установлены (см. предыдущие задания). 
Добавьте корень репозитория в переменную окружения PYTHONPATH и запустите тесты:

```console
$ PYTHONPATH=$ROOT_DIRECTORY_PATH python3 test.py solution
```

Если Вам нужна бОльшая debug информация, добавьте флаг `-d` к тестированию.

Поднимаются 5 процессов пользователей (Alice, Bob, Carl, Dan, Eve), которые коммуницируют между собой через
`test_server`. Все аналогично предыдущим задачам.

Мы уже написали за Вас тесты, которы должны проходить при правильном решении.
Вы можете добавлять новые тесты, по умолчанию они не будут оцениваться.
Однако если вы придумаете и реализуете тест, который увеличит покрытие наших тестов, то за него можно получить бонус 2 балла.
За деталями о том, как мы тестируем, обращайтесь к тестам, осознать, что там происходит -- Ваша задача.

## Оценивание

- Реализация надежной рассылки (aka Reliable Broadcast, свойства 1-3 + 4 только для корректных процессов) - 3 балла
- Реализация свойства 4 (aka Uniform Reliable Broadcast) - 4 балла
- Реализация свойства 5 (aka FIFO Broadcast) - 3 балла

Кроме того, как написано выше, Вы можете попробовать реализовать дополнительные гарантии порядка (Causal или Total Order, см. лекцию). За корректную реализацию, снабженную необходимыми дополнительными тестами, можно получить от 2 (Causal) до 4 (Total) бонусных баллов.

## Сдача

Сдача и проверка решений будет вестись через сервис Gradescope.
См. инструкцию в первой задаче.

Далее зайдите в Assignments, там вы увидите задачу Broadcast, в которую можно
сдавать только zip архивы. Поместите тесты и решение в архив следующей командой:

```console
$ zip -r solution.zip test.py solution/
```

Желательно также добавить в папку `solution` файл `readme.md` с кратким описанием
вашего решения и дополнительными комментариями, который также попадет в архив.

Далее сдайте Ваш `solution.zip`. Дождитесь пока отработают Ваши тесты на Вашем решении
(учтите, что это может занять несколько минут из-за нагрузки серверов). Если все тесты
прошли успешно, то решение проставляется 2 балла и решение принимается на ручную проверку.
Если какие-то тесты не прошли, то выставляется 0 баллов, и решение не принимается на
ручную проверку.

Если Вы не смогли что-то реализовать, можете закомментировать некоторые тесты в [test.py](./test.py),
но обязательно отразите почему Вы это сделали в readme-файле. Это сильно упростит нам проверку.

Дедлайн задачи -- __2 недели__, в Gradescope корректно проставлена дата
окончания.
